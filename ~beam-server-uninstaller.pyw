import os
import shutil
import sys
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import threading
import datetime
import re # For regular expressions to extract shortcut code
import uuid # Used for generating unique IDs in the dummy function, if uncommented
import traceback # Added explicit import for traceback

# Conditional import for pywin32 (Windows-specific for shortcuts)
try:
    import win32com.client
    WINDOWS_SHORTCUT_SUPPORT = True
except ImportError:
    WINDOWS_SHORTCUT_SUPPORT = False


# --- CONFIGURABLE VARIABLES ---
VERSION = "v0.4.0" # Updated version for path display

# List of base directories to scan for BeamMP server installations.
# Add or remove paths as needed where your servers might be installed.
# os.getcwd() refers to the directory where this script is run.
BASE_SCAN_PATHS = [
    os.getcwd(),
    os.path.expanduser("~/Desktop"), # User's Desktop
    os.path.expanduser("~/Documents"), # User's Documents
    os.path.expanduser("~/Downloads"), # User's Downloads
    # Add other common install paths if known, e.g.:
    # os.path.join(os.environ.get("PROGRAMFILES", "C:\\Program Files"), "BeamMP Server"),
]

SERVER_EXE_NAME = "BeamMP-Server.exe"
# The filename that contains the unique shortcut code generated by the installer
SHORTCUT_CODE_FILE = "bsi_code.txt"
# The prefix string expected in the shortcut code file
SHORTCUT_CODE_PREFIX = "generated_bsi_shortcut_code = "
# This regex captures the code within square brackets at the end of a shortcut name
# Format: "NameMe - DO NOT DELETE CODE [RsiChA98xM].lnk"
SHORTCUT_NAME_PATTERN = re.compile(r" - DO NOT DELETE CODE \[([a-zA-Z0-9]+)\]\.lnk$", re.IGNORECASE)
# --- END CONFIGURABLE VARIABLES ---


def get_human_readable_size(path):
    """Calculates the size of a directory in bytes and converts to human-readable format."""
    total_size = 0
    if not os.path.exists(path):
        return "0 Bytes"
    if os.path.isfile(path):
        total_size = os.path.getsize(path)
    else:
        for dirpath, dirnames, filenames in os.walk(path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                try:
                    total_size += os.path.getsize(fp)
                except OSError:
                    # Ignore files that cannot be accessed (e.g., permission denied)
                    pass
                except Exception:
                    # Catch other potential errors like invalid symlinks
                    pass

    if total_size < 1024:
        return f"{total_size} Bytes"
    elif total_size < 1024**2:
        return f"{total_size / 1024:.2f} KB"
    elif total_size < 1024**3:
        return f"{total_size / (1024**2):.2f} MB"
    else:
        return f"{total_size / (1024**3):.2f} GB"

def find_shortcut_by_code(code_to_find):
    """
    Scans common Windows shortcut locations for a shortcut ending with ' - DO NOT DELETE CODE [CODE].lnk'
    where [CODE] matches the code_to_find.
    Returns the full path to the shortcut if found, otherwise None.
    """
    if not WINDOWS_SHORTCUT_SUPPORT:
        return None

    # Common Windows shortcut locations
    shortcut_dirs = [
        os.path.expanduser("~/Desktop"), # Desktop
        os.path.expanduser("~/AppData/Roaming/Microsoft/Windows/Start Menu/Programs"), # Start Menu Programs
        os.path.expanduser("~/AppData/Local/Microsoft/Windows/Start Menu/Programs"), # Alternative Start Menu
        # Add any other specific folders where shortcuts might be placed by your installer
    ]

    for s_dir in shortcut_dirs:
        if not os.path.isdir(s_dir):
            continue
        try:
            for filename in os.listdir(s_dir):
                if filename.lower().endswith(".lnk"):
                    match = SHORTCUT_NAME_PATTERN.search(filename)
                    if match and match.group(1).upper() == code_to_find.upper():
                        return os.path.join(s_dir, filename)
        except PermissionError:
            # Silently skip directories with permission issues during shortcut search
            pass
        except Exception:
            # Catch other general errors during directory listing or regex matching
            pass
    return None


class BeamMPUninstallerGUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(f"BeamMP Server Uninstaller {VERSION}")
        self.geometry("800x700") # Increased height
        self.resizable(False, False)

        self.style = ttk.Style(self)
        self.style.theme_use('clam')

        self.server_data = {} # Stores {display_name: {path, code, type, raw_name}}
        self.selected_server_name = None

        self.create_widgets()
        self.scan_servers() # Initial scan on startup

    def create_widgets(self):
        # Create a main container frame for the left and right panels
        main_content_frame = ttk.Frame(self)
        # This frame fills most of the window, leaving space at the bottom for log_text
        main_content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10) 

        # Left panel for controls and info - packed into main_content_frame
        left_panel = ttk.Frame(main_content_frame, padding="15 15 15 15")
        left_panel.pack(side=tk.LEFT, fill=tk.Y) # No padx/pady here, handled by main_content_frame

        # Delete Button
        self.delete_button = ttk.Button(left_panel, text="Delete Selected Server", command=self.delete_selected_server_threaded, state='disabled')
        self.delete_button.pack(pady=10, fill=tk.X)

        # Status Bar
        ttk.Label(left_panel, text="Status:").pack(pady=(20, 5), anchor="w")
        self.status_label = ttk.Label(left_panel, text="Ready.", wraplength=200)
        self.status_label.pack(fill=tk.X, pady=(0, 5))

        # Folder Size
        ttk.Label(left_panel, text="Folder Size:").pack(pady=(10, 5), anchor="w")
        self.size_label = ttk.Label(left_panel, text="N/A")
        self.size_label.pack(fill=tk.X, pady=(0, 5))

        # Installation Type
        ttk.Label(left_panel, text="Installation Type:").pack(pady=(10, 5), anchor="w")
        self.type_label = ttk.Label(left_panel, text="N/A")
        self.type_label.pack(fill=tk.X, pady=(0, 5))

        # Spacer to push elements to top of left_panel
        ttk.Frame(left_panel).pack(fill=tk.Y, expand=True)

        # Right panel for server list - packed into main_content_frame
        right_panel = ttk.Frame(main_content_frame, padding="15 15 15 15")
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True) # This panel fills remaining space in main_content_frame

        ttk.Label(right_panel, text="Found BeamMP Servers:").pack(pady=(0, 5), anchor="w")

        self.server_listbox = tk.Listbox(right_panel, selectmode=tk.SINGLE, exportselection=False)
        self.server_listbox.pack(fill=tk.BOTH, expand=True)
        self.server_listbox.bind('<<ListboxSelect>>', self.on_server_select)

        # Scrollbar for the listbox
        scrollbar = ttk.Scrollbar(right_panel, orient="vertical", command=self.server_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.server_listbox.config(yscrollcommand=scrollbar.set)

        # Log output area - packed directly into 'self' (the root window) AFTER main_content_frame
        # This ensures it's always at the bottom.
        self.log_text = scrolledtext.ScrolledText(self, wrap=tk.WORD, height=5, state='disabled', font=("Monospace", 8), bg="#f0f0f0")
        self.log_text.pack(fill=tk.X, padx=10, pady=10) 
        self.log_text.tag_config('info', foreground='blue')
        self.log_text.tag_config('error', foreground='red')
        self.log_text.tag_config('success', foreground='green')
        self.log_text.tag_config('warning', foreground='orange')

    def log_message(self, message, message_type='info'):
        """Inserts a message into the scrolled text widget."""
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n", message_type)
        self.log_text.see(tk.END)
        self.log_text.config(state='disabled')
        self.update_idletasks()

    # Thread-safe GUI update methods
    def _schedule_log_message(self, message, message_type='info'):
        self.after(0, lambda: self.log_message(message, message_type))

    def _schedule_update_status(self, message):
        self.after(0, lambda: self.status_label.config(text=message))

    def _schedule_update_size(self, size_text):
        self.after(0, lambda: self.size_label.config(text=size_text))

    def _schedule_update_type(self, type_text):
        self.after(0, lambda: self.type_label.config(text=type_text))

    def _schedule_button_state(self, button, state):
        self.after(0, lambda: button.config(state=state))

    def _schedule_listbox_clear(self):
        self.after(0, self.server_listbox.delete, 0, tk.END)

    def _schedule_listbox_insert(self, index, text):
        self.after(0, lambda: self.server_listbox.insert(index, text))

    def _schedule_listbox_select(self, index):
        self.after(0, lambda: self.server_listbox.selection_set(index))


    def scan_servers(self):
        """Initiates a server scan in a separate thread."""
        self._schedule_log_message("Scanning for BeamMP servers...", 'info')
        self._schedule_update_status("Scanning...")
        self._schedule_button_state(self.delete_button, 'disabled')
        self._schedule_update_size("N/A")
        self._schedule_update_type("N/A")
        self.selected_server_name = None

        scan_thread = threading.Thread(target=self._perform_scan)
        scan_thread.daemon = True
        scan_thread.start()

    def _perform_scan(self):
        """Performs the actual file system scan in a background thread."""
        found_servers = []
        # Clear existing display via scheduled call
        self._schedule_listbox_clear()
        self.server_data = {}

        for base_path in BASE_SCAN_PATHS:
            self._schedule_log_message(f"Searching in: {base_path}", 'info')
            
            # Check the base path itself if it contains the server executable
            server_exe_in_base = os.path.join(base_path, SERVER_EXE_NAME)
            if os.path.isdir(base_path) and os.path.exists(server_exe_in_base) and os.path.isfile(server_exe_in_base):
                found_servers.append(base_path)
            
            # Check direct subdirectories for server installations
            try:
                if os.path.isdir(base_path): # Ensure base_path is a directory before listing
                    for item_name in os.listdir(base_path):
                        full_path = os.path.join(base_path, item_name)
                        server_exe_in_subdir = os.path.join(full_path, SERVER_EXE_NAME)
                        if os.path.isdir(full_path) and os.path.exists(server_exe_in_subdir) and os.path.isfile(server_exe_in_subdir):
                            found_servers.append(full_path)
            except PermissionError:
                self._schedule_log_message(f"Permission denied accessing '{base_path}'. Skipping.", 'warning')
            except Exception as e:
                self._schedule_log_message(f"Error scanning '{base_path}': {e}", 'error')

        display_index = 0
        # Process unique found server paths
        for server_path in sorted(list(set(found_servers))):
            server_name = os.path.basename(server_path)
            server_type = "Manual"
            shortcut_code = None

            bsi_code_file_path = os.path.join(server_path, SHORTCUT_CODE_FILE)
            if os.path.exists(bsi_code_file_path):
                try:
                    with open(bsi_code_file_path, 'r', encoding='utf-8') as f:
                        for line in f:
                            if line.startswith(SHORTCUT_CODE_PREFIX):
                                extracted_code = line.replace(SHORTCUT_CODE_PREFIX, "").strip()
                                # Basic validation: code should not be empty and should be alphanumeric
                                if extracted_code and re.fullmatch(r"[a-zA-Z0-9]+", extracted_code):
                                    shortcut_code = extracted_code
                                    server_type = "Installer Managed"
                                    break
                except Exception as e:
                    self._schedule_log_message(f"Error reading '{SHORTCUT_CODE_FILE}' in '{server_path}': {e}", 'warning')

            # Updated display_name_text to include the path
            display_name_text = f"{server_name} [{server_type}] ({server_path})"
            if server_type == "Installer Managed" and shortcut_code:
                display_name_text = f"{server_name} [Installer Managed: {shortcut_code}] ({server_path})"


            self.server_data[display_name_text] = {
                "path": server_path,
                "code": shortcut_code,
                "type": server_type,
                "raw_name": server_name
            }
            self._schedule_listbox_insert(display_index, display_name_text)
            display_index += 1

        if not found_servers:
            self._schedule_update_status("No BeamMP servers found.")
            self._schedule_log_message("No BeamMP servers found in scanned locations.", 'info')
        else:
            self._schedule_update_status(f"Found {len(found_servers)} server(s). Select one to view details.")
            self._schedule_log_message(f"Scan complete. Found {len(found_servers)} server(s).", 'info')

    def on_server_select(self, event):
        """Handles selection of a server in the listbox."""
        selected_indices = self.server_listbox.curselection()
        if not selected_indices:
            self.selected_server_name = None
            self._schedule_update_status("Ready.")
            self._schedule_update_size("N/A")
            self._schedule_update_type("N/A")
            self._schedule_button_state(self.delete_button, 'disabled')
            return

        index = selected_indices[0]
        self.selected_server_name = self.server_listbox.get(index)
        server_info = self.server_data.get(self.selected_server_name)

        if server_info:
            server_path = server_info["path"]
            server_type = server_info["type"]
            self._schedule_update_status(f"Selected: {server_info['raw_name']}")
            self._schedule_update_size(f"Calculating size for {server_info['raw_name']}...")
            self._schedule_update_type(server_type)

            # Calculate size in a thread to avoid blocking GUI
            size_calc_thread = threading.Thread(target=self._calculate_and_display_size, args=(server_path, server_info['raw_name']))
            size_calc_thread.daemon = True
            size_calc_thread.start()

            if "Manual" in server_type:
                self.delete_button.config(text="Manual Installed Server, Cannot Delete", state='disabled')
                self._schedule_log_message(f"Selected manual server: {server_info['raw_name']}. Deletion not supported by uninstaller.", 'warning')
            else:
                self.delete_button.config(text=f"Delete '{server_info['raw_name']}'", state='normal')
                self._schedule_log_message(f"Selected installer-managed server: {server_info['raw_name']}", 'info')
        else:
            self._schedule_update_status("Error: Server data not found.")
            self._schedule_update_size("N/A")
            self._schedule_update_type("N/A")
            self._schedule_button_state(self.delete_button, 'disabled')

    def _calculate_and_display_size(self, path, name):
        """Calculates and displays folder size, called in a separate thread."""
        try:
            size_text = get_human_readable_size(path)
            self._schedule_update_size(size_text)
            self._schedule_log_message(f"Calculated size for '{name}': {size_text}", 'info')
        except Exception as e:
            self._schedule_log_message(f"Error calculating size for '{name}': {e}", 'error')
            self._schedule_update_size("Error calculating size.")


    def delete_selected_server_threaded(self):
        """Initiates deletion of selected server in a separate thread."""
        if not self.selected_server_name:
            messagebox.showwarning("No Server Selected", "Please select a server to delete from the list.")
            return

        server_info = self.server_data.get(self.selected_server_name)
        if not server_info or "Manual" in server_info["type"]:
            messagebox.showwarning("Deletion Not Allowed", "This server is manually installed and cannot be deleted by this uninstaller.")
            return

        confirm_message = (
            f"Are you sure you want to permanently delete the server folder:\n"
            f"'{server_info['path']}'\n"
        )
        if server_info["code"] and WINDOWS_SHORTCUT_SUPPORT:
            # Explicitly mention the full expected shortcut name pattern for clarity
            confirm_message += (
                f"\nAND its associated shortcut (e.g., 'ServerName - DO NOT DELETE CODE [{server_info['code']}]'.lnk)?"
            )
        else:
            confirm_message += f"\n(No associated shortcut found or shortcut support unavailable.)"

        if messagebox.askyesno("Confirm Deletion", confirm_message):
            self._schedule_update_status(f"Deleting {server_info['raw_name']}...")
            self._schedule_button_state(self.delete_button, 'disabled')
            delete_thread = threading.Thread(target=self._perform_deletion, args=(server_info,))
            delete_thread.daemon = True
            delete_thread.start()

    def _perform_deletion(self, server_info):
        """Performs the actual deletion of folder and shortcut in a background thread."""
        server_path = server_info["path"]
        shortcut_code = server_info["code"]
        raw_name = server_info["raw_name"]
        
        delete_success = True
        
        try:
            self._schedule_log_message(f"Attempting to delete server folder: '{server_path}'", 'info')
            shutil.rmtree(server_path)
            self._schedule_log_message(f"Successfully deleted server folder: '{server_path}'", 'success')
        except OSError as e:
            self._schedule_log_message(f"Error deleting folder '{server_path}': {e}", 'error')
            self._schedule_log_message("Please ensure the folder is not in use and you have permissions.", 'error')
            delete_success = False
        except Exception as e:
            self._schedule_log_message(f"An unexpected error occurred deleting folder '{server_path}': {e}", 'error')
            self._schedule_log_message(f"Traceback:\n{traceback.format_exc()}", 'error')
            delete_success = False

        if delete_success and shortcut_code and WINDOWS_SHORTCUT_SUPPORT:
            self._schedule_log_message(f"Searching for associated shortcut with code '{shortcut_code}'...", 'info')
            shortcut_path = find_shortcut_by_code(shortcut_code)
            if shortcut_path:
                try:
                    self._schedule_log_message(f"Found shortcut: '{shortcut_path}'. Attempting to delete.", 'info')
                    os.remove(shortcut_path)
                    self._schedule_log_message(f"Successfully deleted shortcut: '{shortcut_path}'", 'success')
                except OSError as e:
                    self._schedule_log_message(f"Error deleting shortcut '{shortcut_path}': {e}", 'error')
                    self._schedule_log_message("Please ensure the shortcut is not in use and you have permissions.", 'error')
                except Exception as e:
                    self._schedule_log_message(f"An unexpected error occurred deleting shortcut '{shortcut_path}': {e}", 'error')
                    self._schedule_log_message(f"Traceback:\n{traceback.format_exc()}", 'error')
            else:
                self._schedule_log_message(f"No shortcut found with code '{shortcut_code}'. Skipping shortcut deletion.", 'warning')
        elif shortcut_code and not WINDOWS_SHORTCUT_SUPPORT:
            self._schedule_log_message("Windows shortcut support (pywin32) not installed. Cannot search for/delete shortcut.", 'warning')


        # Finalization on main thread
        self.after(0, self._finalize_deletion_gui, delete_success, raw_name)

    def _finalize_deletion_gui(self, success, raw_name):
        """Updates GUI after deletion attempt and re-scans servers."""
        if success:
            messagebox.showinfo("Deletion Complete", f"Successfully deleted '{raw_name}'.")
            self._schedule_log_message(f"Deletion of '{raw_name}' complete.", 'success')
        else:
            messagebox.showerror("Deletion Failed", f"Failed to delete '{raw_name}'. Check log for details.")
            self._schedule_log_message(f"Deletion of '{raw_name}' failed.", 'error')
        
        self.scan_servers() # Re-scan to update the list and reset state

# --- Dummy Server Generation for Testing (COMMENTED OUT) ---
# This function is for testing purposes only. Uncomment if you need to create dummy servers.
# It will create dummy server folders and shortcuts based on the new naming scheme.
# def _generate_dummy_server_folders_for_testing():
#     """
#     Generates a few dummy BeamMP server folders and associated ignore.txt files
#     with unique codes for testing the uninstaller.
#     """
#     print("Generating dummy server folders for testing...")
#     current_dir = os.getcwd()

#     dummy_servers_data = [
#         {"name": "ManagedServer_A", "managed": True},
#         {"name": "ManagedServer_B", "managed": True},
#         {"name": "ManualServer_X", "managed": False},
#         {"name": "ManualServer_Y", "managed": False}
#     ]

#     for server_info in dummy_servers_data:
#         folder_name = server_info["name"]
#         server_path = os.path.join(current_dir, folder_name)
        
#         os.makedirs(server_path, exist_ok=True)
        
#         # Create BeamMP-Server.exe placeholder
#         with open(os.path.join(server_path, SERVER_EXE_NAME), 'w') as f:
#             f.write("This is a dummy BeamMP-Server.exe")
        
#         # Create a small dummy file to make folder size non-zero
#         with open(os.path.join(server_path, "dummy_log.txt"), 'w') as f:
#             f.write("This is a dummy log file to give the folder some size.\n" * 50)

#         # Create bsi_code.txt for managed servers
#         if server_info["managed"]:
#             shortcut_code = str(uuid.uuid4()).split('-')[0].upper() # Use part of UUID for unique code
#             bsi_code_file_path = os.path.join(server_path, SHORTCUT_CODE_FILE)
#             with open(bsi_code_file_path, 'w') as f:
#                 f.write(f"{SHORTCUT_CODE_PREFIX}{shortcut_code}\n")
#             print(f"Created dummy managed server: {server_path} with code {shortcut_code}")

#             # Optionally create a dummy shortcut (requires pywin32, for demonstration)
#             if WINDOWS_SHORTCUT_SUPPORT:
#                 try:
#                     desktop_path = os.path.expanduser("~/Desktop")
#                     # Adhering to the new shortcut name pattern
#                     shortcut_name = f"{folder_name} - DO NOT DELETE CODE [{shortcut_code}].lnk"
#                     shortcut_path = os.path.join(desktop_path, shortcut_name)
#                     shell = win32com.client.Dispatch("WScript.Shell")
#                     shortcut = shell.CreateShortCut(shortcut_path)
#                     shortcut.Targetpath = os.path.join(server_path, SERVER_EXE_NAME)
#                     shortcut.WorkingDirectory = server_path
#                     shortcut.IconLocation = os.path.join(server_path, SERVER_EXE_NAME)
#                     shortcut.Save()
#                     print(f"  -> Created dummy shortcut on Desktop: {shortcut_path}")
#                 except Exception as e:
#                     print(f"  -> Warning: Could not create dummy shortcut for {folder_name} (Error: {e}). Requires pywin32.")

#         else:
#             print(f"Created dummy manual server: {server_path}")
#     print("Dummy server generation complete.")


if __name__ == "__main__":
    # To generate dummy server folders and shortcuts for testing, uncomment the line below:
    # _generate_dummy_server_folders_for_testing()
    # Remember to comment it out again when you are done testing!

    app = BeamMPUninstallerGUI()
    app.mainloop()
